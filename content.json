{"meta":{"title":"weijiajin","subtitle":"「Stay Hungry.Stay Foolish.」","description":"weijiajin's blog","author":"weijiajin","url":"https://weijiajin.com","root":"/"},"pages":[{"title":"","date":"2020-11-24T12:33:18.161Z","updated":"2020-11-24T12:33:18.155Z","comments":false,"path":"about/index.html","permalink":"https://weijiajin.com/about/index.html","excerpt":"","text":"Stay Hungry.Stay Foolish."},{"title":"","date":"2020-11-24T12:17:29.312Z","updated":"2020-11-24T12:17:29.305Z","comments":true,"path":"404.html","permalink":"https://weijiajin.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-11-24T12:21:46.182Z","updated":"2020-11-24T12:21:46.173Z","comments":true,"path":"categories/index.html","permalink":"https://weijiajin.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-11-24T12:26:31.513Z","updated":"2020-11-24T12:22:00.615Z","comments":true,"path":"tags/index.html","permalink":"https://weijiajin.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"喜欢","slug":"喜欢","date":"2020-11-25T03:06:32.000Z","updated":"2020-11-25T03:18:42.502Z","comments":true,"path":"2020/11/25/喜欢/","link":"","permalink":"https://weijiajin.com/2020/11/25/%E5%96%9C%E6%AC%A2/","excerpt":"","text":"喜欢你，很久了。 想到你，我的情感变得丰富，特别是见到你，你的目光在别处，我们不曾对视。但是，靠近你，我呼吸变得压抑，双手忘了往哪儿放，心变得那么冲动，却佯装淡定，细细地端详着你，只是余光略过，赞叹好美，心中盈满了欢喜。 你留给我的只是一瞬，成了我心中永恒的美丽，我想我不会忘了这种感觉。 有时候，真想勇敢地去真实地追你，可是，理性告诉我，我得不到什么的。 我们无所交际，我心无旁贷的喜欢并注视你，可在你眼中我不过是匆匆的路人，关于我你无所知晓；我的面容不过是路人，而你的笑颜是天使；对于你，我注定要仰望，也只能，只有仰望，只怪自己过于卑微。无论怎样，我依旧喜欢你，只是这喜欢带着青春的模模糊糊，隐隐约约的。 我真的不知道这样单方面的守候，还有多久？你说我会忘了你吗？我想，不会，为什么不会？岁月这么蹉跎？其实我也说不出，只是觉得你是我这段时间感情的全部，这么珍贵的记忆我怎么会忘记，忘了那得有多么对不起现在的自己，对不起想你的艰苦。你说，是吧？我怎么会忘记呢。深夜了，今天就这样吧，还有明天呢。 2015年4月4日深夜写于好久以前，那个幼稚的男孩，他对一个女生清澈的喜欢。现在距离远了，我也淡了，像舞倦的蝴蝶，我有点累了 2020年2月10日傍晚恍然间已过了近5年的光阴，不经感叹，时间过的真快呀！遗憾的是，再读这篇心情日记时，很多美好的记忆变得模糊不清。","categories":[{"name":"prose","slug":"prose","permalink":"https://weijiajin.com/categories/prose/"}],"tags":[{"name":"lina","slug":"lina","permalink":"https://weijiajin.com/tags/lina/"}]},{"title":"姿态","slug":"姿态","date":"2020-11-24T13:18:30.000Z","updated":"2020-11-25T03:16:59.850Z","comments":true,"path":"2020/11/24/姿态/","link":"","permalink":"https://weijiajin.com/2020/11/24/%E5%A7%BF%E6%80%81/","excerpt":"我究竟要以什么样的姿态面对你才觉得，这样很好","text":"我究竟要以什么样的姿态面对你才觉得，这样很好最好时，想见见你可是你在远方，我在故乡 等你回来时，我没有任何准备那么慌张躲藏自己怕被你看到不好的地方特别是脸上的伤疮在你面前，我努力留下好的印象 于是，我时刻提醒自己，要最好认真地等，最好地等等你，等你我在等你 今天，七夕我虔诚地向神祈祷：当我饱含生命的热情与希望向着阳光生长时能够等到那个爱笑的你 在我心中，你笑一笑便最美 我一直以最好的姿态在等你 2015年9月16日","categories":[{"name":"prose","slug":"prose","permalink":"https://weijiajin.com/categories/prose/"}],"tags":[{"name":"wangqian","slug":"wangqian","permalink":"https://weijiajin.com/tags/wangqian/"}]},{"title":"暮然回首","slug":"暮然回首","date":"2020-11-24T13:13:21.000Z","updated":"2020-11-25T03:16:36.498Z","comments":true,"path":"2020/11/24/暮然回首/","link":"","permalink":"https://weijiajin.com/2020/11/24/%E6%9A%AE%E7%84%B6%E5%9B%9E%E9%A6%96/","excerpt":"本是电影里的画面却在这条街戏剧上演是上帝的安排还是神的眷恋","text":"本是电影里的画面却在这条街戏剧上演是上帝的安排还是神的眷恋也许，还有未断的线 那天，我疲倦上演充完话费，故意走在街上好久了，好久没走在这条街了走着走着看见一迷人的背影未带眼镜，需凑近怕尴尬，故作无意没太看清人那么多，没太在心刚要擦肩听见我姓名，被叫停细看，略知意，是你怪我，没看清差点错过了你怪你，为何变的那么美丽还是我淡了你总之，充满着惊喜可是，你身边多了一位没事，你我早已无所交际，我让我，不要在心走在你身后看着你的背影不禁打开相机想记录下这最美的背影你突然微笑回首我慌张收起手机去答应你好久的声音那时，无意，冥冥拍下了你，欣喜不是背影，是你回首那刻最美的一滴好久了，好久没见你了这次见你笑，不是在梦里 太短又要别离再见，下次聊又泛起涟漪你身旁那位是你哥，而不是带着一张你的回首欣喜着梦里依旧 2015年9月15日","categories":[{"name":"poems","slug":"poems","permalink":"https://weijiajin.com/categories/poems/"}],"tags":[{"name":"wangqian","slug":"wangqian","permalink":"https://weijiajin.com/tags/wangqian/"}]},{"title":"期许明天的太阳","slug":"期许明天的太阳","date":"2020-11-24T12:38:27.000Z","updated":"2020-11-25T03:16:46.928Z","comments":true,"path":"2020/11/24/期许明天的太阳/","link":"","permalink":"https://weijiajin.com/2020/11/24/%E6%9C%9F%E8%AE%B8%E6%98%8E%E5%A4%A9%E7%9A%84%E5%A4%AA%E9%98%B3/","excerpt":"希望我粗粝生活的以后某个偶然，邂逅爱情","text":"希望我粗粝生活的以后某个偶然，邂逅爱情我定会满心欢喜只幕你而倾骨子里的浪漫主义也会失而又得的逢生 2019年9月23日我写完关于期许的诗，就开心地入睡了。想着，她呀，她真的太好了。","categories":[{"name":"poems","slug":"poems","permalink":"https://weijiajin.com/categories/poems/"}],"tags":[{"name":"xurong","slug":"xurong","permalink":"https://weijiajin.com/tags/xurong/"}]},{"title":"此刻的美好","slug":"此刻的美好","date":"2020-11-24T11:38:27.000Z","updated":"2020-11-25T03:16:23.966Z","comments":true,"path":"2020/11/24/此刻的美好/","link":"","permalink":"https://weijiajin.com/2020/11/24/%E6%AD%A4%E5%88%BB%E7%9A%84%E7%BE%8E%E5%A5%BD/","excerpt":"此刻的美好如我，如她，如你时间静止的那一刻和十年前的光景,一般相像","text":"此刻的美好如我，如她，如你时间静止的那一刻和十年前的光景,一般相像她是有喜欢的人的你也是她是我眼里西施也是他们口中我讲述的西施想来，不过是我眼中的虚荣她没有全然不自知的美丽只是我不自知的丑陋我满眼都是最喜的月亮想着，近水楼台先得的便一定是月吗我想以后让月亮奔我而来和小时候一样田边会有跟我走的月亮 2019年12月30日那是我第一次和她出去玩，那天晚上的一切在我记忆里都很美，就连站台的寒风也不那么刺骨。","categories":[{"name":"poems","slug":"poems","permalink":"https://weijiajin.com/categories/poems/"}],"tags":[{"name":"xurong","slug":"xurong","permalink":"https://weijiajin.com/tags/xurong/"}]},{"title":"基于深度学习框架Tensorflow的成绩自动查询","slug":"基于深度学习框架Tensorflow的成绩自动查询","date":"2020-11-24T11:02:37.000Z","updated":"2020-11-24T12:36:21.491Z","comments":true,"path":"2020/11/24/基于深度学习框架Tensorflow的成绩自动查询/","link":"","permalink":"https://weijiajin.com/2020/11/24/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6Tensorflow%E7%9A%84%E6%88%90%E7%BB%A9%E8%87%AA%E5%8A%A8%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"项目地址(包含数据集)：https://github.com/feelheart7/Python 项目介绍当考试结束后，有很多同学想及时知道自己的成绩，由于学校成绩在官网最新更新，其他平台查成绩有很大的延迟，所以迫不及待的同学需要去学校官网的教务处查询，过程操作不是很方便，每次凭运气查成绩。于是通过程序自动化操作，简化成绩查询过程，节省时间，提高效率。 项目所需知识 图像数值处理 深度学习 tensorflow python3.6 爬虫 项目优点 第一次查询全部成绩 最新成绩通过邮箱通知，最新成绩显示在邮箱标题 配置简单只需填写 ，学号、密码、和接受通知的邮箱 项目所需库1234567891011121314151617181920212223242526272829303132# 操作图片模块from PIL import Image# 第三方OCR调用（识别率不高）import pytesseract# 范围随机模块import random# 操作系统模块import os# 矩阵计算与tensorflow（深度学习框架）import numpy as npimport tensorflow as tf# 爬虫模拟网页请求模块import requests# 调用系统浏览器import webbrowser# 爬取html指定内容from bs4 import BeautifulSoup# 正则模块import re# smtp邮箱import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddr# 时间模块，用于延迟import time# 下载图片模块from typing import Anyfrom urllib.request import urlretrieve# TF_CPP_MIN_LOG_LEVEL默认值为 0 (显示所有logs)# 设置为 1 隐藏 INFO logs, 2 额外隐藏WARNING logs# 设置为3所有 ERROR logs也不显示os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] &#x3D; &#39;2&#39; 项目难点通过深度神经网络的验证码识别，目前我的验证码的识别率为97%，3万图片经过深度神经网络的训练，使用的是Google的神经网络框架tensorflow，如果还想提高识别率也是可以的，可以增加数据集，降低keep_prob的值（拟合度），达到99.9%是没有问题的。 3万张的数据集并不是我手动码的，而是通过最开始我自己人工识别了1000张和我的好朋友刘雪峰200张作为最初数据集，开始训练的识别率只有20%左右，然后写了个函数将识别正确验证码储存，再进行训练，从而增大数据集和提高数据集（当识别率已经很高的时候，错误的图片再进行人工识别在训练可进一步提高识别率）。 多用户使用方法12345678910info &#x3D; [&#123; &#39;account&#39;: &#39;******, &#39;password&#39;: &#39;******&#39;, &#39;email&#39;: &#39;*****@qq.com&#39; &#125;, &#123; &#39;account&#39;: &#39;****** &#39;password&#39;: &#39;***&#39;, &#39;email&#39;: &#39;*****@qq.com&#39; &#125;] 运行结果 python源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456# coding&#x3D;utf-8# 操作图片模块from PIL import Image# 第三方OCR调用（识别率不高）import pytesseract# 范围随机模块import random# 操作系统模块import os# 矩阵计算与tensorflow（深度学习框架）import numpy as npimport tensorflow as tf# 爬虫模拟网页请求模块import requests# 调用系统浏览器import webbrowser# 爬取html指定内容from bs4 import BeautifulSoup# 正则模块import re# smtp邮箱import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddr# 时间模块，用于延迟import time# 下载图片模块from typing import Anyfrom urllib.request import urlretrieve# TF_CPP_MIN_LOG_LEVEL默认值为 0 (显示所有logs)# 设置为 1 隐藏 INFO logs, 2 额外隐藏WARNING logs# 设置为3所有 ERROR logs也不显示os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;] &#x3D; &#39;2&#39;# 全局变量IMAGE_HEIGHT &#x3D; 22 # 验证码图片高度IMAGE_WIDTH &#x3D; 68 # 验证码图片宽度MAX_CAPTCHA &#x3D; 4 # 验证码的位数CHAR_SET_LEN &#x3D; 36 # 验证码的字符有多少种# 验证码图片网址IMAGE_URL &#x3D; &quot;http:&#x2F;&#x2F;jwfw1.sdjzu.edu.cn&#x2F;ssfw&#x2F;jwcaptcha.do&quot;# 下载验证码图片的数量VERIFICATION_CODE_NUMBER &#x3D; 10# 验证码文件夹与文件绝对存储路径VERIFICATION_CODE_PATH1 &#x3D; os.path.dirname(__file__) + &#39;&#x2F;verification_code_images&#x2F;&#39;VERIFICATION_CODE_PATH2 &#x3D; os.path.dirname(__file__) + &#39;&#x2F;verification_code_images&#x2F;&#123;name&#125;.png&#39;# 训练数据集绝对存储路径VERIFICATION_CODE_TRAINING_PATH &#x3D; os.path.dirname(__file__) + &#39;&#x2F;verification_code_training_images&#x2F;&#39;# placeholder 是 Tensorflow 中的占位符，暂时储存变量 X Y ,keep_prob是dropout层保留概率X &#x3D; tf.placeholder(tf.float32, [None, IMAGE_HEIGHT*IMAGE_WIDTH])Y &#x3D; tf.placeholder(tf.float32, [None, MAX_CAPTCHA*CHAR_SET_LEN])keep_prob &#x3D; tf.placeholder(tf.float32)# 邮箱信息SENDER &#x3D; &#39;********&#39;PASSWORD &#x3D; &#39;********&#39;# 用户信息info &#x3D; [&#123; &#39;account&#39;: &#39;********&#39;, &#39;password&#39;: &#39;********&#39;, &#39;email&#39;: &#39;********&#39; &#125;, &#123; &#39;account&#39;: &#39;********&#39;, &#39;password&#39;: &#39;********&#39;, &#39;email&#39;: &#39;********&#39; &#125;]# String1为原始成绩,String2为最新成绩。创建方式为这样append防止默认copy（以免浅拷贝）String1 &#x3D; [[] for copy in range(len(info))]String2 &#x3D; [[] for copy in range(len(info))]# 训练集所有图片list与all_images &#x3D; os.listdir(VERIFICATION_CODE_TRAINING_PATH)all_images_size &#x3D; len(all_images)# 下载验证码图片安装序号存储图片def download_verification_code(): # 创建文件夹如果没有 os.makedirs(VERIFICATION_CODE_PATH1, exist_ok&#x3D;True) for i in range(0, VERIFICATION_CODE_NUMBER): urlretrieve(IMAGE_URL, VERIFICATION_CODE_PATH2.format(name&#x3D;i)) print(&quot;成功下载%s张图片！&quot; % VERIFICATION_CODE_NUMBER)# 调用pytesseract整体识别验证码(识别率低)def pytesseract_verification_code(): for i in range(0, VERIFICATION_CODE_NUMBER): img &#x3D; Image.open(VERIFICATION_CODE_PATH2.format(name&#x3D;i)) char &#x3D; pytesseract.image_to_string(img, config&#x3D;&#39;--psm 8&#39;) # psm 各个值的说明 # 0：定向脚本监测（OSD） # 1： 使用OSD自动分页 # 2 ：自动分页，但是不使用OSD或OCR（Optical Character Recognition，光学字符识别） # 3 ：全自动分页，但是没有使用OSD（默认） # 4 ：假设可变大小的一个文本列。 # 5 ：假设垂直对齐文本的单个统一块。 # 6 ：假设一个统一的文本块。 # 7 ：将图像视为单个文本行。 # 8 ：将图像视为单个词。 # 9 ：将图像视为圆中的单个词。 # 10 ：将图像视为单个字符 print(i, char)# 二值化分割验证码再调用pytesseract识别验证码(识别率有所提高)def pytesseract_devide_verification_code(): # 随机读取图片并灰度化 random_number &#x3D; random.randint(0, VERIFICATION_CODE_NUMBER) img &#x3D; Image.open(VERIFICATION_CODE_PATH2.format(name&#x3D;random_number)).convert(&#39;L&#39;) # 二值化:173为我的验证图片有较好的效果的值，不同图片的值不一样，请根据自己验证码图片设置相应的值 img &#x3D; img.point(lambda x: 255 if x &gt; 173 else 0) # 分离:crop函数带的参数为(起始点的横坐标，起始点的纵坐标，宽度，高度） img1 &#x3D; img.crop((0 * IMAGE_WIDTH &#x2F; MAX_CAPTCHA, 0, 1 * IMAGE_WIDTH &#x2F; MAX_CAPTCHA, IMAGE_HEIGHT)) img2 &#x3D; img.crop((1 * IMAGE_WIDTH &#x2F; MAX_CAPTCHA, 0, 2 * IMAGE_WIDTH &#x2F; MAX_CAPTCHA, IMAGE_HEIGHT)) img3 &#x3D; img.crop((2 * IMAGE_WIDTH &#x2F; MAX_CAPTCHA, 0, 3 * IMAGE_WIDTH &#x2F; MAX_CAPTCHA, IMAGE_HEIGHT)) img4 &#x3D; img.crop((3 * IMAGE_WIDTH &#x2F; MAX_CAPTCHA, 0, 4 * IMAGE_WIDTH &#x2F; MAX_CAPTCHA, IMAGE_HEIGHT)) # 调用pytesseract识别验证码 char &#x3D; pytesseract.image_to_string(img, config&#x3D;&#39;--psm 8&#39;) char1 &#x3D; pytesseract.image_to_string(img1, config&#x3D;&#39;--psm 10&#39;) char2 &#x3D; pytesseract.image_to_string(img2, config&#x3D;&#39;--psm 10&#39;) char3 &#x3D; pytesseract.image_to_string(img3, config&#x3D;&#39;--psm 10&#39;) char4 &#x3D; pytesseract.image_to_string(img4, config&#x3D;&#39;--psm 10&#39;) print(char) print(char1) print(char2) print(char3) print(char4)################################################################### 通过tensorflow的CNN(卷积神经网络深度学习后识别验证码,识别率贼高##################################################################### 获取验证码名字和图片（训练数据集）def get_name_and_image(): # 获取数据集下的所有图片的数组all_images # all_images &#x3D; os.listdir(VERIFICATION_CODE_TRAINING_PATH) random_image &#x3D; random.randint(0, all_images_size - 1) # print (all_images_size) base &#x3D; os.path.basename(VERIFICATION_CODE_TRAINING_PATH + all_images[random_image]) # 有扩展名 name &#x3D; os.path.splitext(base)[0] # 无扩展名 image &#x3D; Image.open(VERIFICATION_CODE_TRAINING_PATH + all_images[random_image]) image &#x3D; np.array(image) return name, image# 验证码名字转变成向量: 不同位数的需要重写这个函数,函数里的数字为ASCII码def name2vec(name): vector &#x3D; np.zeros(MAX_CAPTCHA*CHAR_SET_LEN) for i, c in enumerate(name): if ord(c) &lt; 58: idx &#x3D; i * 36 + ord(c)-48 vector[idx] &#x3D; 1 else: idx &#x3D; i * 36 + ord(c) - 87 vector[idx] &#x3D; 1 return vector# 向量转名字:注释部分是 最开始的向量 转 名字# def vec2name(vec):# name &#x3D; []# for i, c in enumerate(vec):# if c &#x3D;&#x3D; 1.0:# name.append(i)# for i in range(0, 4):# if name[i] % 36 &lt; 10:# name[i] &#x3D; chr(name[i] % 36 + 48)# else:# name[i] &#x3D; chr(name[i] % 36 + 87)# return &quot;&quot;.join(name)# 向量转名字: 训练是不用到这个函数，训练完成用这个函数得到最终结果def vec2name(vec): name &#x3D; [] for i in vec: if i &lt; 10: a &#x3D; chr(i + 48) name.append(a) else: a &#x3D; chr(i + 87) name.append(a) return &quot;&quot;.join(name)# 采样函数:默认一次采集64张验证码作为一次训练# 需要注意通过get_name_and_image()函数获得的image是一个含布尔值的矩阵# 在这里通过1*(image.flatten())函数转变成只含0和1的1行114*450列的矩阵def get_next_batch(batch_size&#x3D;64): batch_x &#x3D; np.zeros([batch_size, IMAGE_HEIGHT*IMAGE_WIDTH]) batch_y &#x3D; np.zeros([batch_size, MAX_CAPTCHA*CHAR_SET_LEN]) for i in range(batch_size): name, image &#x3D; get_name_and_image() batch_x[i, :] &#x3D; 1*(image.flatten()) batch_y[i, :] &#x3D; name2vec(name) return batch_x, batch_y# 定义CNN(卷积神经网络):三个卷积层卷积神经网络结构# 采用3个卷积层加1个全连接层的结构，在每个卷积层中都选用2*2的最大池化层和dropout层，卷积核尺寸选择5*5。，# 我们的图片已经经过了3层池化层，也就是长宽都压缩了8倍(各自取整为3X9)def crack_captcha_cnn(w_alpha&#x3D;0.01, b_alpha&#x3D;0.1): x &#x3D; tf.reshape(X, shape&#x3D;[-1, IMAGE_HEIGHT, IMAGE_WIDTH, 1]) # 3个卷积层 w_c1 &#x3D; tf.Variable(w_alpha * tf.random_normal([5, 5, 1, 32])) b_c1 &#x3D; tf.Variable(b_alpha * tf.random_normal([32])) conv1 &#x3D; tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(x, w_c1, strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;SAME&#39;), b_c1)) conv1 &#x3D; tf.nn.max_pool(conv1, ksize&#x3D;[1, 2, 2, 1], strides&#x3D;[1, 2, 2, 1], padding&#x3D;&#39;SAME&#39;) conv1 &#x3D; tf.nn.dropout(conv1, keep_prob) w_c2 &#x3D; tf.Variable(w_alpha * tf.random_normal([5, 5, 32, 64])) b_c2 &#x3D; tf.Variable(b_alpha * tf.random_normal([64])) conv2 &#x3D; tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(conv1, w_c2, strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;SAME&#39;), b_c2)) conv2 &#x3D; tf.nn.max_pool(conv2, ksize&#x3D;[1, 2, 2, 1], strides&#x3D;[1, 2, 2, 1], padding&#x3D;&#39;SAME&#39;) conv2 &#x3D; tf.nn.dropout(conv2, keep_prob) w_c3 &#x3D; tf.Variable(w_alpha * tf.random_normal([5, 5, 64, 64])) b_c3 &#x3D; tf.Variable(b_alpha * tf.random_normal([64])) conv3 &#x3D; tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(conv2, w_c3, strides&#x3D;[1, 1, 1, 1], padding&#x3D;&#39;SAME&#39;), b_c3)) conv3 &#x3D; tf.nn.max_pool(conv3, ksize&#x3D;[1, 2, 2, 1], strides&#x3D;[1, 2, 2, 1], padding&#x3D;&#39;SAME&#39;) conv3 &#x3D; tf.nn.dropout(conv3, keep_prob) # 1个全连接层 w_d &#x3D; tf.Variable(w_alpha * tf.random_normal([3*9*64, 1024])) b_d &#x3D; tf.Variable(b_alpha * tf.random_normal([1024])) dense &#x3D; tf.reshape(conv3, [-1, w_d.get_shape().as_list()[0]]) dense &#x3D; tf.nn.relu(tf.add(tf.matmul(dense, w_d), b_d)) dense &#x3D; tf.nn.dropout(dense, keep_prob) w_out &#x3D; tf.Variable(w_alpha * tf.random_normal([1024, MAX_CAPTCHA * CHAR_SET_LEN])) b_out &#x3D; tf.Variable(b_alpha * tf.random_normal([MAX_CAPTCHA * CHAR_SET_LEN])) out &#x3D; tf.add(tf.matmul(dense, w_out), b_out) return out# 训练函数：选择sigmoid_cross_entropy_with_logits()交叉熵来比较loss# 用adam优化器来优化# keep_prob &#x3D; 0.3，控制着过拟合def train_crack_captcha_cnn(): output &#x3D; crack_captcha_cnn() loss &#x3D; tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits&#x3D;output, labels&#x3D;Y)) optimizer &#x3D; tf.train.AdamOptimizer(learning_rate&#x3D;0.0001).minimize(loss) predict &#x3D; tf.reshape(output, [-1, MAX_CAPTCHA, CHAR_SET_LEN]) max_idx_p &#x3D; tf.argmax(predict, 2) max_idx_l &#x3D; tf.argmax(tf.reshape(Y, [-1, MAX_CAPTCHA, CHAR_SET_LEN]), 2) correct_pred &#x3D; tf.equal(max_idx_p, max_idx_l) accuracy &#x3D; tf.reduce_mean(tf.cast(correct_pred, tf.float32)) saver &#x3D; tf.train.Saver() with tf.Session() as sess: sess.run(tf.global_variables_initializer()) step &#x3D; 0 while True: batch_x, batch_y &#x3D; get_next_batch(256) _, loss_ &#x3D; sess.run([optimizer, loss], feed_dict&#x3D;&#123;X: batch_x, Y: batch_y, keep_prob: 0.2&#125;) print(step, loss_) # 每100 step计算一次准确率 if step % 1000 &#x3D;&#x3D; 0: batch_x_test, batch_y_test &#x3D; get_next_batch(1000) acc &#x3D; sess.run(accuracy, feed_dict&#x3D;&#123;X: batch_x_test, Y: batch_y_test, keep_prob: 1.&#125;) print(step, acc) # 如果准确率大于99%,保存模型,完成训练 if acc &gt; 0.999: saver.save(sess, &quot;.&#x2F;crack_capcha.model&quot;, global_step&#x3D;step) break step +&#x3D; 1# train_crack_captcha_cnn()# 训练完成后,注释train_crack_captcha_cnn()，取消下面的注释，开始预测，注意更改预测集目录# def crack_captcha():# output &#x3D; crack_captcha_cnn()## saver &#x3D; tf.train.Saver()# with tf.Session() as sess:# saver.restore(sess, tf.train.latest_checkpoint(&#39;.&#39;))# n &#x3D; 1# while n &lt;&#x3D; 10:# text, verification_code_training_images &#x3D; get_name_and_image()# verification_code_training_images &#x3D; 1 * (verification_code_training_images.flatten())# predict &#x3D; tf.argmax(tf.reshape(output, [-1, MAX_CAPTCHA, CHAR_SET_LEN]), 2)# text_list &#x3D; sess.run(predict, feed_dict&#x3D;&#123;X: [verification_code_training_images], keep_prob: 1&#125;)# vec &#x3D; text_list[0].tolist()# predict_text &#x3D; vec2name(vec)# print(&quot;正确: &#123;&#125; 预测: &#123;&#125;&quot;.format(text, predict_text))# n +&#x3D; 1### crack_captcha()def captcha(): output &#x3D; crack_captcha_cnn() saver &#x3D; tf.train.Saver() with tf.Session() as sess: saver.restore(sess, tf.train.latest_checkpoint(&#39;.&#39;)) first_time &#x3D; True while True: users_number &#x3D; 0 for information in info: while True: session &#x3D; requests.Session() headers &#x3D; &#123;&quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:39.0) Gecko&#x2F;20100101 Firefox&#x2F;39.0&quot;&#125; html &#x3D; session.get(IMAGE_URL, headers&#x3D;headers).content with open(&#39;.&#x2F;test_captcha&#x2F;test.png&#39;, &#39;wb&#39;) as file: file.write(html) img &#x3D; Image.open(&#39;.&#x2F;test_captcha&#x2F;test.png&#39;).convert(&#39;L&#39;) # 二值化 img &#x3D; img.point(lambda x: 255 if x &gt; 173 else 0) img &#x3D; np.array(img) img &#x3D; 1 * (img.flatten()) predict &#x3D; tf.argmax(tf.reshape(output, [-1, MAX_CAPTCHA, CHAR_SET_LEN]), 2) text_list &#x3D; sess.run(predict, feed_dict&#x3D;&#123;X: [img], keep_prob: 1&#125;) vec &#x3D; text_list[0].tolist() # print(&quot;预测:&quot;, vec2name(vec)) session.get(&#39;http:&#x2F;&#x2F;jwfw1.sdjzu.edu.cn&#x2F;ssfw&#x2F;login.jsp&#39;) data &#x3D; &#123;&#39;j_username&#39;: information[&#39;account&#39;], &#39;j_password&#39;: information[&#39;password&#39;], &#39;validateCode&#39;: vec2name(vec)&#125; r &#x3D; session.post(&#39;http:&#x2F;&#x2F;jwfw1.sdjzu.edu.cn&#x2F;ssfw&#x2F;j_spring_ids_security_check&#39;, data&#x3D;data, headers&#x3D;headers) if (re.search(r&#39;校验码错误&#39;, r.text, re.I | re.M)) is None: print(&quot;验证码正确通过！&quot;) n &#x3D; session.get( &#39;http:&#x2F;&#x2F;jwfw1.sdjzu.edu.cn&#x2F;ssfw&#x2F;jwnavmenu.do?menuItemWid&#x3D;1E057E24ABAB4CAFE0540010E0235690&#39;, headers&#x3D;headers) soup &#x3D; BeautifulSoup(n.content, features&#x3D;&#39;html.parser&#39;) s &#x3D; soup.select(&#39;div[title&#x3D;&quot;有效成绩&quot;] .t_con td[align&#x3D;&quot;center&quot;]&#39;) subjects_number &#x3D; int(len(s) &#x2F; 11) # print(&quot;科目数:&quot;, subjects_number) for i in range(0, subjects_number): # print(&#39;序号:&#39;, s[i * 11].get_text(strip&#x3D;True)) # print(&#39;学年学期:&#39;, s[i * 11 + 1].get_text( strip&#x3D;True)) # print(&#39;课程号:&#39;, s[i * 11 + 2].get_text(strip&#x3D;True)) # print(&#39;课程名称:&#39;, s[i * 11 + 3].get_text( strip&#x3D;True)) # print(&#39;课程类别:&#39;, s[i * 11 + 4].get_text(strip&#x3D;True)) # print(&#39;任选课类别:&#39;, s[i * 11 + 5].get_text(strip&#x3D;True)) # print(&#39;课程性质:&#39;, s[i * 11 + 6].get_text(strip&#x3D;True)) # print(&#39;学分:&#39;, s[i * 11 + 7].get_text(strip&#x3D;True)) # print(&#39;成绩:&#39;, s[i * 11 + 8].get_text(strip&#x3D;True)) # print(&#39;****************&#39;) ss &#x3D; &#39;&#123;&#125; &#123;&#125; 成绩: &#123;&#125;&#39;.format(s[i * 11].get_text(strip&#x3D;True), s[i * 11 + 3].get_text(strip&#x3D;True), s[i * 11 + 8].get_text(strip&#x3D;True)) if first_time: String1[users_number].append(ss) else: String2[users_number].append(ss) # 发送邮件 my_user &#x3D; &#39;%s&#39; % information[&#39;email&#39;] sss &#x3D; &quot;&quot;.join(list(set(String2[users_number]).difference(set(String1[users_number])))) # b中有而a中没有的 ret &#x3D; True if first_time: text &#x3D; &#39;\\n&#39;.join(String1[users_number]) try: msg &#x3D; MIMEText(text, &#39;plain&#39;, &#39;utf-8&#39;) msg[&#39;From&#39;] &#x3D; formataddr([&quot;weijiajin&quot;, SENDER]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg[&#39;To&#39;] &#x3D; formataddr([&quot;亲～:&quot;, my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg[&#39;Subject&#39;] &#x3D; &quot;全部成绩！好好学习！&quot; # 邮件的主题，也可以说是标题 server &#x3D; smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465) # 发件人邮箱中的SMTP服务器，端口是465 server.login(SENDER, PASSWORD) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(SENDER, [my_user, ], msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret&#x3D;False ret &#x3D; False if ret: print(&quot;发送邮件成功！&quot;) else: print(&quot;发送邮件失败！&quot;) String2[users_number].clear() users_number &#x3D; + 1 break elif sss &#x3D;&#x3D; &quot;&quot;: print(&quot;没有最新成绩！不发送邮件！&quot;) String2[users_number].clear() users_number &#x3D; + 1 break elif sss !&#x3D; &quot;&quot;: text &#x3D; &#39;\\n&#39;.join(String2[users_number]) title &#x3D; &quot;&quot;.join(list(set(String2[users_number]).difference(set(String1[users_number])))) try: msg &#x3D; MIMEText(text, &#39;plain&#39;, &#39;utf-8&#39;) msg[&#39;From&#39;] &#x3D; formataddr([&quot;weijiajin&quot;, SENDER]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg[&#39;To&#39;] &#x3D; formataddr([&quot;亲～&quot;, my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg[&#39;Subject&#39;] &#x3D; &quot;最新成绩出来啦～&quot; + title # 邮件的主题，也可以说是标题 server &#x3D; smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465) # 发件人邮箱中的SMTP服务器，端口是465 server.login(SENDER, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(SENDER, [my_user, ], msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret&#x3D;False ret &#x3D; False if ret: print(&quot;发送邮件成功！&quot;) else: print(&quot;发送邮件失败！&quot;) String1[users_number].clear() String1[users_number] &#x3D; String2[users_number] String2[users_number].clear() users_number &#x3D; + 1 break time.sleep(300) else: print(&quot;校验码错误！重新尝试中......&quot;) first_time &#x3D; Falsedef auto_download_train_images(): output &#x3D; crack_captcha_cnn() saver &#x3D; tf.train.Saver() with tf.Session() as sess: saver.restore(sess, tf.train.latest_checkpoint(&#39;.&#39;)) times1 &#x3D; 0 times2 &#x3D; 0 while True: session &#x3D; requests.Session() headers &#x3D; &#123;&quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (X11; Ubuntu; Linux x86_64; rv:39.0) Gecko&#x2F;20100101 Firefox&#x2F;39.0&quot;&#125; html &#x3D; session.get(IMAGE_URL, headers&#x3D;headers).content with open(&#39;.&#x2F;test_captcha&#x2F;test.png&#39;, &#39;wb&#39;) as file: file.write(html) img &#x3D; Image.open(&#39;.&#x2F;test_captcha&#x2F;test.png&#39;).convert(&#39;L&#39;) # 二值化 img &#x3D; img.point(lambda x: 255 if x &gt; 173 else 0) img1 &#x3D; np.array(img) img1 &#x3D; 1 * (img1.flatten()) predict &#x3D; tf.argmax(tf.reshape(output, [-1, MAX_CAPTCHA, CHAR_SET_LEN]), 2) text_list &#x3D; sess.run(predict, feed_dict&#x3D;&#123;X: [img1], keep_prob: 1&#125;) vec &#x3D; text_list[0].tolist() # print(&quot;预测:&quot;, vec2name(vec)) session.get(&#39;http:&#x2F;&#x2F;jwfw1.sdjzu.edu.cn&#x2F;ssfw&#x2F;login.jsp&#39;) data &#x3D; &#123;&#39;j_username&#39;: &#39;201611101122&#39;, &#39;j_password&#39;: &#39;174519&#39;, &#39;validateCode&#39;: vec2name(vec)&#125; r &#x3D; session.post(&#39;http:&#x2F;&#x2F;jwfw1.sdjzu.edu.cn&#x2F;ssfw&#x2F;j_spring_ids_security_check&#39;, data&#x3D;data, headers&#x3D;headers) if (re.search(r&#39;校验码错误&#39;, r.text, re.I | re.M)) is None: # print(&quot;验证码正确通过！&quot;) # print(times1) image_name &#x3D; &#39;&#123;image_name&#125;.png&#39; img.save(os.path.join(&#39;.&#x2F;verification_code_training_images&#x2F;&#39;, image_name.format(image_name&#x3D;vec2name(vec)))) times1 &#x3D; times1 + 1 else: # print(&quot;校验码错误！&quot;) # print(times2) image_name &#x3D; &#39;&#123;image_name&#125;.png&#39; img.save(os.path.join(&#39;.&#x2F;error_images&#x2F;&#39;, image_name.format(image_name&#x3D;vec2name(vec)))) times2 &#x3D; times2 + 1 rate &#x3D; times1&#x2F;(times2+times1) print(&quot;总次数: % s&quot; % (times2+times1)+&quot;正确率：% s &quot; % rate)captcha()# auto_download_train_images() TODO： 增加绩点计算公式 集成于微信小程序或者微信公众号 优化代码 参考资料 https://morvanzhou.github.io/ https://www.iswin.org/2016/10/15/Simple-CAPTCHA-Recognition-with-Machine-Learning/ https://finthon.com/python-tensorflow-cnn-captcha/ http://blog.topspeedsnail.com/archives/10858","categories":[{"name":"python","slug":"python","permalink":"https://weijiajin.com/categories/python/"}],"tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"https://weijiajin.com/tags/tensorflow/"},{"name":"python","slug":"python","permalink":"https://weijiajin.com/tags/python/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-11-21T16:00:00.000Z","updated":"2020-11-24T11:12:31.625Z","comments":true,"path":"2020/11/22/hello-world/","link":"","permalink":"https://weijiajin.com/2020/11/22/hello-world/","excerpt":"","text":"Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; Run server1$ hexo s Generate static files1$ hexo g Deploy to remote sites1$ hexo d","categories":[{"name":"hexo","slug":"hexo","permalink":"https://weijiajin.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://weijiajin.com/tags/hexo/"}]}],"categories":[{"name":"prose","slug":"prose","permalink":"https://weijiajin.com/categories/prose/"},{"name":"poems","slug":"poems","permalink":"https://weijiajin.com/categories/poems/"},{"name":"python","slug":"python","permalink":"https://weijiajin.com/categories/python/"},{"name":"hexo","slug":"hexo","permalink":"https://weijiajin.com/categories/hexo/"}],"tags":[{"name":"lina","slug":"lina","permalink":"https://weijiajin.com/tags/lina/"},{"name":"wangqian","slug":"wangqian","permalink":"https://weijiajin.com/tags/wangqian/"},{"name":"xurong","slug":"xurong","permalink":"https://weijiajin.com/tags/xurong/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://weijiajin.com/tags/tensorflow/"},{"name":"python","slug":"python","permalink":"https://weijiajin.com/tags/python/"},{"name":"hexo","slug":"hexo","permalink":"https://weijiajin.com/tags/hexo/"}]}